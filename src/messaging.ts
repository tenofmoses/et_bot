// –í–°–Å –ü–†–û –°–û–û–ë–©–ï–ù–ò–Ø: –æ—Ç–ø—Ä–∞–≤–∫–∞/—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å —Ä–µ—Ç—Ä–∞—è–º–∏ + –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–µ–∫—Å—Ç–æ–≤
import TelegramBot from 'node-telegram-bot-api';
import { Tournament } from './types';

const DEBUG_MSG = true;

function log(...args: any[]) {
  if (DEBUG_MSG) {
    console.debug('[MSG]', ...args);
  }
}

/**
 * –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π —Å —Ä–µ—Ç—Ä–∞—è–º–∏.
 * –û—Å–æ–±—ã–µ —Å–ª—É—á–∞–∏:
 *  - 429 (rate limit): –∂–¥—ë–º —É–∫–∞–∑–∞–Ω–Ω–æ–µ Telegram retry_after (–∏–ª–∏ 5—Å).
 *  - –¥—Ä—É–≥–∏–µ –æ—à–∏–±–∫–∏: —ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–π backoff (2^attempt —Å–µ–∫—É–Ω–¥).
 */
export async function sendMessageWithRetry(
  bot: TelegramBot,
  chatId: number,
  text: string,
  options: any = {},
  maxRetries = 3
): Promise<any> {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      log(`sendMessage attempt #${attempt}`, { chatId, textPreview: text.slice(0, 60) });
      const result = await bot.sendMessage(chatId, text, options);
      log('sendMessage ok', { messageId: result.message_id });
      return result;
    } catch (error: any) {
      const code = error?.response?.body?.error_code;
      const desc = error?.response?.body?.description || error?.message;
      log('sendMessage failed', { attempt, code, desc });

      if (code === 429) {
        const retryAfter = error?.response?.body?.parameters?.retry_after || 5;
        log(`rate limited: sleep ${retryAfter}s`);
        await new Promise(res => setTimeout(res, retryAfter * 1000));
      } else if (attempt < maxRetries) {
        const delay = Math.pow(2, attempt) * 1000;
        log(`backoff: sleep ${delay}ms`);
        await new Promise(res => setTimeout(res, delay));
      } else {
        log('sendMessage giving up');
        throw error;
      }
    }
  }
}

/**
 * –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏–π —Å —Ä–µ—Ç—Ä–∞—è–º–∏.
 * –°–ø–µ—Ü-–∫–µ–π—Å: "message is not modified" ‚Äî –ø—Ä–æ—Å—Ç–æ –≤—ã—Ö–æ–¥–∏–º –±–µ–∑ –æ—à–∏–±–∫–∏.
 */
export async function editMessageWithRetry(
  bot: TelegramBot,
  chatId: number,
  messageId: number,
  text: string,
  options: any = {},
  maxRetries = 3
): Promise<any> {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      log(`editMessage attempt #${attempt}`, { chatId, messageId, textPreview: text.slice(0, 60) });
      const result = await bot.editMessageText(text, {
        chat_id: chatId,
        message_id: messageId,
        ...options,
      });
      log('editMessage ok');
      return result;
    } catch (error: any) {
      const desc = error?.response?.body?.description || error?.message || '';
      const code = error?.response?.body?.error_code;
      if (desc.includes('message is not modified')) {
        log('editMessage skipped: not modified');
        return null;
      }
      log('editMessage failed', { attempt, code, desc });

      if (code === 429) {
        const retryAfter = error?.response?.body?.parameters?.retry_after || 5;
        log(`rate limited: sleep ${retryAfter}s`);
        await new Promise(res => setTimeout(res, retryAfter * 1000));
      } else if (attempt < maxRetries) {
        const delay = Math.pow(2, attempt) * 1000;
        log(`backoff: sleep ${delay}ms`);
        await new Promise(res => setTimeout(res, delay));
      } else {
        log('editMessage giving up');
        throw error;
      }
    }
  }
}

/**
 * –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —á–µ–ª–æ–≤–µ–∫–æ—á–∏—Ç–∞–µ–º–æ–≥–æ —Ç–µ–∫—Å—Ç–∞ —Ç—É—Ä–Ω–∏—Ä–Ω–æ–π —Å–µ—Ç–∫–∏ –¥–ª—è –æ—Ç–¥–µ–ª—å–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è.
 */
export function buildBracketText(tournament: Tournament): string {
  if (!tournament.bracket) return '';
  let txt = 'üèÜ –¢–£–†–ù–ò–†–ù–ê–Ø –°–ï–¢–ö–ê üèÜ\n\n';

  if (tournament.bracket.byePlayer && tournament.bracket.byeRound !== undefined) {
    txt += `üéØ ${tournament.bracket.byePlayer.name} –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—Å—è –≤ —Ä–∞—É–Ω–¥–µ ${tournament.bracket.byeRound + 1}\n\n`;
  }

  tournament.bracket.rounds.forEach((round, roundIndex) => {
    txt += `–†–∞—É–Ω–¥ ${roundIndex + 1}:\n`;
    round.matches.forEach((match) => {
      const status = match.completed ? '‚úÖ' : '‚è≥';
      if (match.player1.name === 'TBD' || (match.player2 && match.player2.name === 'TBD')) {
        txt += `${status} –û–∂–∏–¥–∞–Ω–∏–µ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤\n`;
      } else if (!match.player2) {
        txt += `${status} ${match.player1.name} (–æ–¥–∏–Ω–æ—á–Ω—ã–π)`;
        if (match.winner) txt += ` ‚Üí ${match.winner.name}`;
        txt += '\n';
      } else {
        txt += `${status} ${match.player1.name} vs ${match.player2.name}`;
        if (match.winner) txt += ` ‚Üí ${match.winner.name}`;
        txt += '\n';
      }
    });
    txt += '\n';
  });

  return txt;
}

/**
 * –ì–µ–Ω–µ—Ä–∞—Ü–∏—è ¬´—à–∞–ø–∫–∏¬ª —Ç—É—Ä–Ω–∏—Ä–∞ –¥–ª—è –∑–∞–∫—Ä–µ–ø–ª—ë–Ω–Ω–æ–≥–æ/–≥–ª–∞–≤–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è.
 * –ï—Å–ª–∏ —Ç—É—Ä–Ω–∏—Ä –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ ‚Äî –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–µ—Ç–∫—É –∏ —Ç–µ–∫—É—â–∏–π –º–∞—Ç—á.
 */
export function buildTournamentHeader(t: Tournament): string {
  const participantsList =
    t.participants.size > 0
      ? Array.from(t.participantNames.values()).map((name, i) => `${i + 1}. ${name}`).join('\n')
      : '_–ü–æ–∫–∞ –Ω–∏–∫–æ–≥–æ –Ω–µ—Ç_';

  let msg = `üèÜ –¢–£–†–ù–ò–† üèÜ\n\nüëë –û—Ä–≥–∞–Ω–∏–∑–∞—Ç–æ—Ä: ${t.organizerName}`;
  if (t.startTime) msg += `\n‚è∞ –í—Ä–µ–º—è –Ω–∞—á–∞–ª–∞: ${t.startTime}`;
  msg += `\n\nüë• –£—á–∞—Å—Ç–Ω–∏–∫–∏ (${t.participants.size}):\n${participantsList}`;

  if (t.gameState === 'playing' && t.bracket) {
    msg += '\n\nüèÜ –¢–£–†–ù–ò–†–ù–ê–Ø –°–ï–¢–ö–ê üèÜ\n\n';
    if (t.bracket.byePlayer && t.bracket.byeRound !== undefined) {
      msg += `üéØ ${t.bracket.byePlayer.name} –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—Å—è –≤ —Ä–∞—É–Ω–¥–µ ${t.bracket.byeRound + 1}\n\n`;
    }
    t.bracket.rounds.forEach((round, roundIndex) => {
      msg += `–†–∞—É–Ω–¥ ${roundIndex + 1}:\n`;
      round.matches.forEach((match) => {
        const status = match.completed ? '‚úÖ' : '‚è≥';
        if (match.player1.name === 'TBD' || (match.player2 && match.player2.name === 'TBD')) {
          msg += `${status} –û–∂–∏–¥–∞–Ω–∏–µ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤\n`;
        } else if (!match.player2) {
          msg += `${status} ${match.player1.name} (–æ–¥–∏–Ω–æ—á–Ω—ã–π)`;
          if (match.winner) msg += ` ‚Üí ${match.winner.name}`;
          msg += '\n';
        } else {
          msg += `${status} ${match.player1.name} vs ${match.player2.name}`;
          if (match.winner) msg += ` ‚Üí ${match.winner.name}`;
          msg += '\n';
        }
      });
      msg += '\n';
    });

    if (t.currentRound !== undefined && t.currentMatch !== undefined) {
      const cr = t.bracket.rounds[t.currentRound];
      const cm = cr.matches[t.currentMatch];
      msg += `üéØ –¢–ï–ö–£–©–ò–ô –ú–ê–¢–ß (–†–∞—É–Ω–¥ ${t.currentRound + 1}):\n`;
      if (!cm.player2) msg += `${cm.player1.name} (–æ–¥–∏–Ω–æ—á–Ω—ã–π –º–∞—Ç—á)`;
      else msg += `${cm.player1.name} vs ${cm.player2.name}`;

      if (cm.player1.roll !== undefined || (cm.player2 && cm.player2.roll !== undefined)) {
        msg += '\n\nüìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã:\n';
        if (cm.player1.roll !== undefined) msg += `${cm.player1.name}: ${cm.player1.roll}\n`;
        if (cm.player2 && cm.player2.roll !== undefined) msg += `${cm.player2.name}: ${cm.player2.roll}\n`;
      }
    }
  } else {
    msg += '\n\nüéØ –ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∏–ª–∏ –≤—ã–π—Ç–∏!';
  }

  return msg;
}

/** –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–µ—Ç–∫—É –æ—Ç–¥–µ–ª—å–Ω—ã–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º (–µ—Å–ª–∏ –æ–Ω–∞ –µ—Å—Ç—å) */
export async function sendTournamentBracket(bot: TelegramBot, chatId: number, t: Tournament) {
  const text = buildBracketText(t);
  if (!text) {
    log('sendTournamentBracket: no bracket text, skip');
    return;
  }
  log('sendTournamentBracket: sending bracket');
  await sendMessageWithRetry(bot, chatId, text, { message_thread_id: t.messageThreadId });
}

/** –°–ª—É–∂–µ–±–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è ‚Äî –ø–µ—Ä–µ—Ö–æ–¥/–≤–∫–ª–µ–π–∫–∞/–∞–≤—Ç–æ–ø—Ä–æ—Ö–æ–¥ */
export async function announceRoundTransition(bot: TelegramBot, chatId: number, t: Tournament) {
  log('announceRoundTransition:', { nextRound: t.currentRound! + 1 });
  await sendMessageWithRetry(
    bot,
    chatId,
    `üîÑ –ü–ï–†–ï–•–û–î –ö –†–ê–£–ù–î–£ ${t.currentRound! + 1}`,
    { message_thread_id: t.messageThreadId }
  );
}

export async function announceByeJoins(bot: TelegramBot, chatId: number, t: Tournament) {
  log('announceByeJoins');
  await sendMessageWithRetry(
    bot,
    chatId,
    `üéØ –ò–≥—Ä–æ–∫ —Å bye –ø—Ä–∏—Å–æ–µ–¥–∏–Ω—è–µ—Ç—Å—è –∫ —ç—Ç–æ–º—É —Ä–∞—É–Ω–¥—É`,
    { message_thread_id: t.messageThreadId }
  );
}

export async function announceAutoAdvance(bot: TelegramBot, chatId: number, t: Tournament, playerName: string) {
  log('announceAutoAdvance:', playerName);
  await sendMessageWithRetry(
    bot,
    chatId,
    `üéØ ${playerName} –ø—Ä–æ—Ö–æ–¥–∏—Ç –¥–∞–ª—å—à–µ (–æ–¥–∏–Ω–æ—á–Ω—ã–π –º–∞—Ç—á).`,
    { message_thread_id: t.messageThreadId }
  );
}

/**
 * –ü—Ä–æ–º–ø—Ç —Ç–µ–∫—É—â–µ–≥–æ –º–∞—Ç—á–∞: –≤—ã–≤–æ–¥–∏—Ç —Ç–µ–∫—Å—Ç –∏ –∫–Ω–æ–ø–∫—É ¬´–ö–∏–Ω—É—Ç—å –∫—É–±–∏–∫¬ª.
 * –ë–µ–∑–æ–ø–∞—Å–Ω–æ –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ cm.player2 —Å—É—â–µ—Å—Ç–≤—É–µ—Ç (–≤ –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ –º–∞—Ç—á ‚Äî –æ–¥–∏–Ω–æ—á–Ω—ã–π –∏ —Å—é–¥–∞ –Ω–µ –∑–∞–π–¥—ë–º).
 */
export async function promptMatch(bot: TelegramBot, chatId: number, t: Tournament, matchNumber: number) {
  const cr = t.currentRound!;
  const cm = t.bracket!.rounds[cr].matches[t.currentMatch!];
  const text = `üéØ –ú–ê–¢–ß ${matchNumber} (–†–∞—É–Ω–¥ ${cr + 1})\n\n${cm.player1.name} vs ${cm.player2!.name}\n\n–í—ã –¥–æ–ª–∂–Ω—ã –±—Ä–æ—Å–∏—Ç—å –∫—É–±–∏–∫!`;
  const keyboard = { inline_keyboard: [[{ text: 'üé≤ –ö–∏–Ω—É—Ç—å –∫—É–±–∏–∫', callback_data: 'throw_dice' }]] };
  log('promptMatch:', { round: cr + 1, match: matchNumber, p1: cm.player1.name, p2: cm.player2?.name });
  await sendMessageWithRetry(bot, chatId, text, {
    reply_markup: keyboard,
    message_thread_id: t.messageThreadId
  });
}
